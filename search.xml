<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025 United Kingdom and Ireland Programming Contest (UKIEPC 2025) 2025 英国 ICPC——L. Last Orders</title>
    <url>/2026/02/07/20260207-50756bd8/</url>
    <content><![CDATA[题目大意题目总结：L. Last Orders
1. 核心目标
在所有酒吧关闭前，尽可能多地喝掉按顺序给出的品脱（Pints）。任务是计算最大可饮用数量。
2. 场景规则

起始状态：时间为 0，位于 1 号酒吧。

饮酒消耗：第  杯酒需要花费时间 。必须按  的固定顺序饮用。

地点限制：

时间限制：**每个酒吧 ******** 有其绝对关门时间 ******。饮酒操作必须在酒吧关门之前或准时完成。

移动消耗：酒吧间通过 ******** 条双向道路连接，每条路有对应的行驶时间。


根据题目意思，酒馆关闭仅意味着不能在这个地方饮酒，不意味着就是该节点无法通过。
3. 样例解释

样例 1：

样例 2：


思路讲解这道题目还是没有那么难的。这个是我们所采用的这个状态定义。
$$dp[node][pint]&#x3D;time$$
转移采用分段转移的这个策略，就是每次只转移一步。
    ll ans=0;    vector&lt;vector&lt;ll&gt;&gt; dp_old(N+3,vector&lt;ll&gt;(R+3,INF));    **//  第一个节点不喝酒，就从这里转移过来**    dp_old[1][0]=0;    if (tim_drink[1]&lt;=close_pub_tim[1]) &#123;		    **// 第一个节点喝酒，就从这里转移**        dp_old[1][1]=tim_drink[1];        ans=1;    &#125;    for (int ci=1;ci&lt;=R+1;++ci) &#123;**        // 因为我们有最短路保证        // 因此我们每次转移都必须喝酒，因为不喝酒，你来这个节点干什么？毕竟有最短路保证**        // **不过第一个节点可以不喝酒。**        vector&lt;vector&lt;ll&gt;&gt; dp_new=dp_old;        for (int u=1;u&lt;=N;++u) &#123;		        **// 因为节点第一个节点可以喝酒，也可以不喝酒。所以说有的节点比别的节点转移稍微慢一拍，		        // 所以我们要照顾到转移稍微慢一拍的。所以我们从 ci 减一和 ci 转移。**            for (ll pint=ci-1;pint&lt;=ci;++pint) &#123;                ll tim=dp_old[u][pint];                for (int to=1;to&lt;=N;++to) &#123;                    if (to==u) continue;                    if (shortest_path[u][to]==INF) continue;                    ll val=tim+shortest_path[u][to]+tim_drink[pint+1];                    **// 判断是否可以喝完这杯酒**                    if (val&lt;=close_pub_tim[to]) &#123;                        dp_new[to][pint+1]=min(dp_new[to][pint+1],val);                        ans=max(ans,pint+1);                    &#125;                &#125;            &#125;        &#125;        swap(dp_new,dp_old);    &#125;    ans=min(ans,R);    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;

AC代码AChttps://qoj.ac/submission/2015239
源代码
心路历程（WA，TLE，MLE……）https://qoj.ac/submission/2014564
故意WA了一发，呃呃，这个是故意的。呃，我故意就是没有考虑到呃零节点，他呃就一节点他不喝酒的情况。
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>graph</tag>
        <tag>shortest path 最短路</tag>
        <tag>预处理 pre processing</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1078-赛后总结（Codeforces Round 1078 (Div. 2)）</title>
    <url>/2026/02/08/20260208-30145394/</url>
    <content><![CDATA[基本情况做出来三道题目，哎，最后最后一道D题哎呀，稍微差一点，应该是DP是DP出来了，但是DP的还原啊，差几秒钟啊，差几秒钟应该是写出来了，或者写出来也就是差一点啊，就反正哎比较可惜吧。
心得感悟感悟的话，反正就是这个CF这个分数啊还是哎就没有那么重要。就是打比赛的时候呢，就是嗯不用呃就怎么说呢？就是你都开始写这道题目了，那么就也不用看榜了。
宝呢你就容易打断节奏。虽然其实这道题目也没有也没有说浪费很多时间吧。就是呃不用特别在意这个时间上的这个问题。我们写这个程序呢呃能用 bitset 哎还有什么之类的，都可以用，然后去减缓这个呃去减少对于实现上面的这个要求。
然后所谓的我们我总结出来的节奏就是呃写一部分，然后就写一部分调一部分，写好一部分以后，我们就呃查看一下这一部分的这个情况。
还有就是我发现命名啊，就是这个循环变量的命名还是可以更加规范一些，还是可以更加规范一些循环变量命名也可以使用 column和 row。
然后输入和预处理部分，最好分开来写。呃，这一这一次也是出现的这个呃写在一起，它这个循环变量搞来搞去，有点搞错的。
]]></content>
      <tags>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 United Kingdom and Ireland Programming Contest (UKIEPC 2025) 2025 英国 ICPC——H. Hybrid Search（混合搜索）</title>
    <url>/2026/02/07/20260207-30045394/</url>
    <content><![CDATA[题目大意题目总结：H. Hybrid Search（混合搜索）问题描述给定一棵以  为根、包含  个节点的树。对于树上的特定目标节点 ，你需要计算在以下两种“混合搜索”策略下， 被访问到的最小可能位置（从  开始计数）：

策略 A (BFS DFS)：从根节点开始进行 广度优先搜索 (BFS)，在某一节点 处切换为 深度优先搜索 (DFS)。切换后，搜索将仅限于 的子树内部。

策略 B (DFS BFS)：从根节点开始进行 深度优先搜索 (DFS)，在某一节点 处切换为 广度优先搜索 (BFS)。切换后，搜索将仅限于 的子树内部。


规则说明

*切换点 **：可以是路径上的任意节点（包括根节点 或节点 本身）。切换时 必须已被第一阶段搜索访问。

搜索范围限制：一旦切换搜索类型，后续只能访问 的子树节点。这意味着为了能访问到 ，切换点 必须是 的祖先（或 本身）。

邻居访问顺序：在任何搜索中，节点子树的访问顺序严格遵循输入中边出现的先后顺序。

计算目标：分别输出在策略 A 和策略 B 下，节点 可能出现的最小位次。



样例解释样例 1 ()
BFS DFS：最优选择是在节点 处切换。BFS 首先访问第一层及第二层部分节点，到达 后切换为 DFS 进入其子树，此时 是第 个被访问的节点。

DFS BFS：最优选择是在节点 或 处切换，最小位次为 。


样例 2 ()
BFS DFS：最小位次为 。

DFS BFS：即使不切换（一直使用 DFS），最小位次也可以达到 。


样例 3 ()
无论哪种混合搜索，最优答案均为 。注意，如果仅使用纯 BFS 或纯 DFS，节点 的位次都是 。混合搜索通过在特定节点（如 的祖先）切换策略，跳过了其他非必要的分支，从而提前了 的访问顺序。


输入输出要求

输入：第一行 ；接下来 行描述边。

输出：第一行输出策略 A 的最小值，第二行输出策略 B 的最小值。

数据范围：。


思路讲解AC代码源代码
心路历程（WA，TLE，MLE……）]]></content>
      <tags>
        <tag>dfs</tag>
        <tag>bfs 广搜</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2026/02/07/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
</search>
